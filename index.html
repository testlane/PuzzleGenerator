<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Worträtsel-Generator (druckfertig)</title>
<style>
  :root {
    --bg: #0f172a;        /* slate-900 */
    --muted: #94a3b8;     /* slate-400 */
    --fg: #e5e7eb;        /* gray-200 */
    --acc: #22d3ee;       /* cyan-400 */
    --ok:#a7f3d0;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    --radius: 12px;
  }
  html, body { height: 100%; background: var(--bg); color: var(--fg); margin: 0; }
  body { display: flex; flex-direction: column; gap: 12px; }
  header { padding: 14px 16px 0; }
  header h1 { margin: 0 0 6px; font-size: 1.25rem; }
  header p { margin: 0; color: var(--muted); font-size: .9rem; }
  .container { padding: 12px 16px 24px; display: grid; grid-template-columns: 1fr; gap: 12px; }
  @media(min-width: 920px) { .container { grid-template-columns: 340px 1fr; align-items: start; } }
  .card {
    background: linear-gradient(180deg, #0b1220 0%, #0b1220 60%, #0a1020 100%);
    border: 1px solid #1f2937;
    border-radius: var(--radius);
    padding: 12px;
  }
  .card h2 { font-size: 1rem; margin: 0 0 10px; color: var(--acc); }
  .grid { display: grid; gap: 6px; }
  .row { display: grid; grid-auto-flow: column; gap: 6px; }
  .cell {
    font-family: var(--mono); text-align: center; padding: 6px 0;
    border-radius: 6px; border: 1px solid #23314a; background: #0b1220; user-select: all;
  }
  .controls label { display: block; font-size: .85rem; color: var(--muted); margin-top: 8px; }
  .controls input[type="number"], .controls input[type="text"] {
    width: 100%; margin-top: 4px; padding: 10px 12px; border-radius: 10px;
    border: 1px solid #253247; background: #0b1220; color: var(--fg); font-size: 1rem; outline: none;
  }
  .controls input[type="file"] { margin-top: 6px; }
  .controls textarea {
    width: 100%; min-height: 170px; margin-top: 6px; padding: 10px 12px; border-radius: 10px;
    border: 1px solid #253247; background: #0b1220; color: var(--fg); font-size: .95rem; font-family: var(--mono);
  }
  .rowbtns { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
  button {
    appearance: none; border: 0; cursor: pointer; padding: 10px 14px; border-radius: 999px; font-weight: 600;
    background: radial-gradient(100% 100% at 0% 0%, #0ea5e9 0%, #22d3ee 100%); color: #001018;
  }
  button.secondary { background: #1f2937; color: var(--fg); }
  button.warn { background: #2b2b0a; color: #ffeaa7; border: 1px solid #44420a; }
  .hint { color: var(--muted); font-size: .85rem; margin-top: 6px; }
  .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; font-size:.75rem; background:#10203a; color:#a5b4fc; border:1px solid #1e2b4a; }
  .metrics { display:flex; gap:10px; flex-wrap:wrap; }
  .status { font-size:.9rem; color: var(--muted); }
  .ok { color: var(--ok); }
  .box { border: 1px dashed #2b3a57; border-radius: 10px; padding: 10px; background:#0a1222; }
  .code { white-space: pre-wrap; word-break: break-word; font-family: var(--mono); }
  .divider { height:1px; background:#1f2937; margin: 12px 0; }

  /* ----- PRINT LAYOUT (A4) ----- */
  @page { size: A4 portrait; margin: 14mm; }
  #printPage { display: none; }
  #printPage .sheet {
    width: 100%; height: auto; background: #fff; color: #000;
    display: grid; grid-template-columns: 1fr 2fr; grid-template-rows: auto 1fr auto; gap: 10mm;
    padding: 4mm;
    box-sizing: border-box;
  }
  #printPage .title { grid-column: 1 / -1; font-size: 16pt; font-weight: 700; }
  #printPage .wordlist {
    grid-column: 1; font-size: 11pt; line-height: 1.35; white-space: pre-wrap;
    border: 1px solid #000; padding: 6mm; border-radius: 2mm; background:#fff;
  }
  #printPage .gridWrap {
    grid-column: 2; display: grid; gap: 1.5mm; align-content: start; background:#fff;
  }
  #printPage .gridRow { display: grid; grid-auto-flow: column; gap: 1.5mm; }
  #printPage .gridCell {
    width: 8.5mm; height: 8.5mm;
    border: 0.4mm solid #000; display: flex; align-items: center; justify-content: center; font-family: var(--mono);
    font-size: 14pt; background: #fff; color:#000;
  }
  #printPage .solutionBox {
    grid-column: 1 / -1; border-top: 0.4mm solid #000; padding-top: 5mm; font-size: 12pt; background:#fff; color:#000;
  }

  /* In-Page Vorschau ohne echtes Drucken */
  body.preview header,
  body.preview .nonPrint,
  body.preview .container { display:none !important; }
  body.preview { background:#fff; color:#000; }
  body.preview #printPage { display:block !important; padding: 10mm 14mm; }
  .previewBar { display:none; }
  body.preview .previewBar {
    display:flex; gap:10px; padding:10px 14px; position:sticky; top:0; background:#fff; border-bottom:1px solid #ddd;
  }

  @media print {
    body { background: #fff; color: #000; }
    header, .controls, .rowbtns, .hint, .hideOnPrint, .container > .card:first-child, .nonPrint, .previewBar { display:none !important; }
    #printPage { display: block !important; }
    .card { border: 0; }
  }
</style>
</head>
<body>
  <header class="nonPrint">
    <h1>Worträtsel-Generator</h1>
    <p>Erstelle ein Puzzle und nutze dann <strong>Vorschau</strong> (mobile-freundlich) oder <strong>Drucken</strong> (Desktop).</p>
  </header>

  <div class="container nonPrint">
    <section class="card controls">
      <h2>Einstellungen</h2>
      <label>Zeilen (R)<input id="rows" type="number" min="5" max="40" value="13" /></label>
      <label>Spalten (C)<input id="cols" type="number" min="5" max="40" value="13" /></label>
      <label>Lösungswort (Restwort; genau diese Anzahl freie Felder)<input id="solution" type="text" value="FEUERWEHR" /></label>
      <div style="display:flex; gap:10px;">
        <label style="flex:1;">Min. Wortlänge<input id="minlen" type="number" min="2" max="30" value="4" /></label>
        <label style="flex:1;">Max. Wortlänge<input id="maxlen" type="number" min="2" max="30" value="10" /></label>
      </div>
      <div class="hint">Richtungen: 8 (E,W,S,N,SE,SW,NE,NW), annähernd gleich verteilt.</div>
      <div class="divider"></div>
      <h2>Wortliste</h2>
      <input id="file" class="hideOnPrint" type="file" accept=".txt" />
      <div class="hint hideOnPrint">Optional: TXT (eine Zeile = ein Wort). Sonst wird die Liste unten verwendet.</div>
      <textarea id="wordlist" spellcheck="false" class="mono" placeholder="Eine Zeile pro Wort … (Umlaute/ß werden normalisiert)"></textarea>
      <details class="hideOnPrint">
        <summary style="margin-top:8px; cursor:pointer;">Beispiel/Werkseinstellung einfügen</summary>
        <div class="rowbtns">
          <button type="button" class="secondary" id="loadDefault">Standardliste laden</button>
        </div>
      </details>
      <div class="divider"></div>
      <label>Max. Versuche (Suchen bis Treffer)<input id="maxAttempts" type="number" min="1" max="200000" value="20000" /></label>
      <div class="rowbtns">
        <button id="run">Starten</button>
        <button id="stop" class="warn" type="button">Stoppen</button>
        <button id="previewBtn" class="secondary" type="button">Vorschau (Seite anzeigen)</button>
        <button id="printBtn" class="secondary" type="button">Drucken/Export</button>
        <button id="downloadBtn" class="secondary" type="button">App-HTML speichern</button>
        <button id="downloadPrintOnlyBtn" class="secondary" type="button">Druckseite speichern</button>
      </div>
      <div id="status" class="status">Bereit.</div>
    </section>

    <section class="card">
      <h2>Ausgabe</h2>
      <div class="metrics">
        <span class="pill" id="attemptsPill">Versuche: 0</span>
        <span class="pill" id="placedPill">Platziert: 0</span>
      </div>
      <div id="gridHost" class="grid" style="margin-top:10px;"></div>
      <div class="divider"></div>
      <div class="box">
        <strong>Wortliste (platziert, für den Solver):</strong>
        <pre id="wordsPlain" class="code" style="margin-top:6px;"></pre>
      </div>
      <div class="divider"></div>
      <div class="box">
        <strong>Placements (Wort  Richtung  (Zeile,Spalte)):</strong>
        <pre id="placements" class="code" style="margin-top:6px;"></pre>
      </div>
      <div class="divider"></div>
      <div class="box">
        <strong>Checksummen</strong>
        <div class="code" style="margin-top:6px;">
          <div>CHECKSUM_GRID_SHA1: <span id="gridSha"></span></div>
          <div>CHECKSUM_WORDS_SHA1: <span id="wordsSha"></span></div>
          <div>solver_leftover: <span id="leftover"></span></div>
        </div>
      </div>
    </section>
  </div>

  <!-- Sticky Bar shown only in preview mode -->
  <div class="previewBar">
    <button id="leavePreview" class="secondary" type="button">Zurück</button>
    <button id="systemPrint" type="button">System-Druckdialog öffnen</button>
  </div>

  <!-- Dedicated print page -->
  <section id="printPage">
    <div class="sheet" id="sheetRoot">
      <div class="title">Worträtsel</div>
      <div class="wordlist" id="printWordlist"></div>
      <div class="gridWrap" id="printGrid"></div>
      <div class="solutionBox">
        <strong>Lösungswort:</strong>
        <span id="solutionPlaceholder" style="display:inline-block; min-width: 80mm; border-bottom: 0.4mm solid #000; height: 6mm;"></span>
      </div>
    </div>
  </section>

<script>
/*** ---------- Utilities ---------- ***/
const DIRS = {
  "E":  [0, 1], "W":  [0,-1], "S":  [1, 0], "N":  [-1,0],
  "SE": [1, 1], "SW": [1,-1], "NE": [-1,1], "NW": [-1,-1],
};
const DIR_LIST = Object.keys(DIRS);

function norm(s) {
  if (!s) return "";
  s = s.trim()
       .replace(/ä/g,"ae").replace(/ö/g,"oe").replace(/ü/g,"ue").replace(/ß/g,"ss")
       .replace(/Ä/g,"Ae").replace(/Ö/g,"Oe").replace(/Ü/g,"Ue")
       .replace(/[^A-Za-z]/g, "");
  return s.toUpperCase();
}
function sha1hex(msg) { // tiny SHA-1 (unchanged)
  function rotl(n,s){ return (n<<s)|(n>>> (32-s)); }
  function tohex(i){ return ('00000000'+(i>>>0).toString(16)).slice(-8); }
  const utf8 = new TextEncoder().encode(msg);
  const ml = utf8.length * 8;
  const withOne = new Uint8Array(((utf8.length + 9 + 63) >> 6) << 6);
  withOne.set(utf8);
  withOne[utf8.length] = 0x80;
  const dv = new DataView(withOne.buffer);
  dv.setUint32(withOne.length - 4, ml, false);
  let h0=0x67452301, h1=0xEFCDAB89, h2=0x98BADCFE, h3=0x10325476, h4=0xC3D2E1F0;
  const w = new Uint32Array(80);
  for (let i=0;i<withOne.length;i+=64){
    for (let j=0;j<16;j++) w[j]=dv.getUint32(i+j*4,false);
    for (let j=16;j<80;j++) w[j]=rotl(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);
    let a=h0,b=h1,c=h2,d=h3,e=h4;
    for (let j=0;j<80;j++){
      const f = j<20 ? ((b&c)|((~b)&d)) : j<40 ? (b^c^d) : j<60 ? ((b&c)|(b&d)|(c&d)) : (b^c^d);
      const k = j<20 ? 0x5A827999 : j<40 ? 0x6ED9EBA1 : j<60 ? 0x8F1BBCDC : 0xCA62C1D6;
      const t = (rotl(a,5) + f + e + k + w[j])|0;
      e=d; d=c; c=rotl(b,30); b=a; a=t;
    }
    h0=(h0+a)|0; h1=(h1+b)|0; h2=(h2+c)|0; h3=(h3+d)|0; h4=(h4+e)|0;
  }
  return tohex(h0)+tohex(h1)+tohex(h2)+tohex(h3)+tohex(h4);
}

class XorShift32 {
  constructor(seed){ this.x = seed|0 || 88675123; }
  next(){ let x=this.x; x ^= x<<13; x ^= x>>>17; x ^= x<<5; this.x=x; return (x>>>0)/4294967296; }
  randInt(n){ return Math.floor(this.next()*n); }
  choice(arr){ return arr[this.randInt(arr.length)]; }
}

function seedFromCrypto(){
  try {
    const a = new Uint32Array(1);
    (self.crypto || window.crypto).getRandomValues(a);
    return a[0] || (Date.now()|0);
  } catch(e){
    return (Date.now() ^ (Math.random()*0xFFFFFFFF))|0;
  }
}

function shuffleInPlace(arr, rng){
  for (let i=arr.length-1; i>0; i--){
    const j = rng.randInt(i+1);
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
/** Weighted random order that favors longer words but varies every run.
    Uses Gumbel-top-k trick: key = log(w_i) + Gumbel(0), sort by key desc.
    weight(length) = length ** alpha (alpha > 1 strengthens the preference). */
function weightedShuffle(words, rng, alpha=1.5){
  function gumbel(){
    // ensure (0,1) exclusive
    let u = rng.next();
    while (u <= 0 || u >= 1) u = rng.next();
    return -Math.log(-Math.log(u));
  }
  // Precompute keys
  const scored = words.map(w => {
    const L = Math.max(1, w.length);
    const weight = Math.pow(L, alpha);
    const key = Math.log(weight) + gumbel();
    return { w, key };
  });
  scored.sort((a,b) => b.key - a.key);
  return scored.map(s => s.w);
}

}

/*** ---------- Core helpers ---------- ***/
function makeEmpty(R,C,val=null){ return Array.from({length:R},_=>Array.from({length:C},_=>val)); }
function inb(r,c,R,C){ return r>=0 && r<R && c>=0 && c<C; }

function can_place(grid, w, r0, c0, dr, dc){
  const R=grid.length, C=grid[0].length;
  let overlap=0;
  for (let i=0;i<w.length;i++){
    const r=r0+dr*i, c=c0+dc*i;
    if (!inb(r,c,R,C)) return [false,0,0];
    const cell=grid[r][c];
    if (cell!==null && cell!==w[i]) return [false,0,0];
    if (cell===w[i]) overlap++;
  }
  const new_cells = w.length - overlap;
  return [true, overlap, new_cells];
}

function place(grid, used, w, r0, c0, dr, dc){
  const path=[];
  for (let i=0;i<w.length;i++){
    const r=r0+dr*i, c=c0+dc*i;
    grid[r][c]=w[i]; used[r][c]=true; path.push([r,c]);
  }
  return path;
}

function count_unused(used){
  let s=0;
  for (let r=0;r<used.length;r++)
    for (let c=0;c<used[0].length;c++)
      if (!used[r][c]) s++;
  return s;
}

function solver_leftover(grid_lines, placed_words){
  const R=grid_lines.length, C=grid_lines[0].length;
  const grid = grid_lines.map(row=>row.split(""));
  const mark = Array.from({length:R}, ()=>Array(C).fill(false));
  const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
  function inb2(r,c){ return r>=0 && r<R && c>=0 && c<C; }
  function mark_word(w){
    const L=w.length;
    for (let r=0;r<R;r++) for (let c=0;c<C;c++) {
      for (const [dr,dc] of dirs){
        let rr=r, cc=c, ok=true;
        for (let k=0;k<L;k++){
          if (!inb2(rr,cc) || grid[rr][cc]!==w[k]){ ok=false; break; }
          rr+=dr; cc+=dc;
        }
        if (ok){
          rr=r; cc=c;
          for (let k=0;k<L;k++){ mark[rr][cc]=true; rr+=dr; cc+=dc; }
        }
      }
    }
  }
  for (const w of placed_words) mark_word(w);
  let out="";
  for (let r=0;r<R;r++) for (let c=0;c<C;c++) if (!mark[r][c]) out+=grid[r][c];
  return out;
}

/*** ---------- Main generation attempt (one seed) ---------- ***/
function generate_uniform_capped_once(R,C,solution,words,seed){
  const rng = new XorShift32(seed);
  const target = solution.length;
  let grid = makeEmpty(R,C,null);
  let used = makeEmpty(R,C,false);
  let placed = [];
  let paths = [];
  let dir_counts = Object.fromEntries(Object.keys(DIRS).map(d=>[d,0]));

  // RANDOMIZE selection: de-dup then shuffle, then prioritize by length (stable tie-break by shuffle)
  const pool = Array.from(new Set(words));
  shuffleInPlace(pool, rng);
  pool.sort((a,b)=>b.length - a.length); // longer first, but ties stay randomized

  function rebuild(){
    grid = makeEmpty(R,C,null);
    used = makeEmpty(R,C,false);
    dir_counts = Object.fromEntries(Object.keys(DIRS).map(d=>[d,0]));
    for (let i=0;i<placed.length;i++){
      const [w,d,[r0,c0]] = placed[i];
      const [dr,dc] = DIRS[d];
      for (let k=0;k<w.length;k++){
        const r=r0+dr*k, c=c0+dc*k;
        grid[r][c]=w[k]; used[r][c]=true;
      }
      dir_counts[d]++;
    }
  }

  for (const w of pool){
    if (count_unused(used) <= target) break;
    let best = null;
    for (let t=0;t<200;t++){
      const d = DIR_LIST[rng.randInt(DIR_LIST.length)];
      const [dr,dc] = DIRS[d];
      const total_after = placed.length+1;
      const desired_low = Math.floor(total_after/8);
      const desired_high = Math.ceil(total_after/8);
      if (dir_counts[d]+1 > desired_high) continue;
      const r0 = rng.randInt(R), c0 = rng.randInt(C);
      const [ok, ov, newc] = can_place(grid,w,r0,c0,dr,dc);
      if (!ok) continue;
      if (count_unused(used)-newc < target) continue;
      const bonus = (dir_counts[d] < desired_low) ? 20 : 0;
      const score = ov*30 - newc*2 + bonus;
      if (!best || score > best.score) best = {score, d, r0, c0, ov, newc};
    }
    if (!best) continue;
    const {d,r0,c0} = best;
    const [dr,dc] = DIRS[d];
    const path = place(grid,used,w,r0,c0,dr,dc);
    placed.push([w,d,[r0,c0]]);
    paths.push(path);
    dir_counts[d]++;
  }

  while (count_unused(used) < target && paths.length){
    placed.pop(); paths.pop();
    rebuild();
  }

  if (count_unused(used) !== target) return null;

  // fill with solution letters
  let letters = solution.split(""), idx=0;
  for (let r=0;r<R;r++) for (let c=0;c<C;c++) if (!used[r][c]) grid[r][c]=letters[idx++];

  const grid_lines = Array.from({length:R}, (_,r)=>grid[r].join(""));
  const leftover = solver_leftover(grid_lines, placed.map(p=>p[0]));
  if (leftover !== solution) return null;

  return { grid: grid_lines, placed, dir_counts };
}

/*** ---------- Search loop & UI wiring ---------- ***/
let running = false;
let attempts = 0;
let baseSeed = seedFromCrypto(); // new per page load

function textAreaToWords(txt, minLen, maxLen, solution) {
  const raw = txt.split(/\r?\n/).map(s=>norm(s)).filter(Boolean);
  const set = new Set();
  for (const w of raw) {
    if (w && w!==solution && w.length>=minLen && w.length<=maxLen) set.add(w);
  }
  return Array.from(set);
}

function renderGrid(gridLines){
  const host = document.getElementById("gridHost");
  host.innerHTML = "";
  host.style.gridTemplateRows = `repeat(${gridLines.length}, auto)`;
  for (const row of gridLines){
    const rowEl = document.createElement("div");
    rowEl.className = "row";
    rowEl.style.gridTemplateColumns = `repeat(${row.length}, 1fr)`;
    for (const ch of row){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.textContent = ch;
      rowEl.appendChild(cell);
    }
    host.appendChild(rowEl);
  }
}

function updateStatus(msg, cls=""){
  const el = document.getElementById("status");
  el.textContent = msg;
  el.className = "status " + cls;
}

async function startSearch(){
  baseSeed = seedFromCrypto(); // reseed each run

  if (running) return;
  const R = +document.getElementById("rows").value;
  const C = +document.getElementById("cols").value;
  const sol = norm(document.getElementById("solution").value);
  const minLen = +document.getElementById("minlen").value;
  const maxLen = +document.getElementById("maxlen").value;
  const maxAttempts = +document.getElementById("maxAttempts").value;
  const txt = document.getElementById("wordlist").value;

  if (!sol || sol.length > R*C){
    updateStatus("Ungültiges Lösungswort (leer oder länger als R×C).", "err");
    return;
  }
  running = true;
  attempts = 0;
  document.getElementById("attemptsPill").textContent = `Versuche: 0`;
  document.getElementById("placedPill").textContent = `Platziert: 0`;
  document.getElementById("wordsPlain").textContent = "";
  document.getElementById("placements").textContent = "";
  document.getElementById("gridSha").textContent = "";
  document.getElementById("wordsSha").textContent = "";
  document.getElementById("leftover").textContent = "";
  document.getElementById("gridHost").innerHTML = "";

  const words = textAreaToWords(txt, minLen, maxLen, sol);
  if (!words.length){
    updateStatus("Keine Wörter nach Filterung gefunden.", "err");
    running = false; return;
  }

  updateStatus("Suche läuft …");
  const chunk = 50;
  function tryChunk(resolve){
    if (!running){ resolve(null); return; }
    for (let i=0;i<chunk;i++){
      attempts++;
      const res = generate_uniform_capped_once(R,C,sol,words,(baseSeed ^ attempts) | 0);
      if (attempts % 50 === 0) {
        updateStatus(`… noch keine Lösung, Versuche: ${attempts}`);
        document.getElementById("attemptsPill").textContent = `Versuche: ${attempts}`;
      }
      if (res){ resolve(res); return; }
      if (attempts >= maxAttempts){ resolve(null); return; }
    }
    setTimeout(()=>tryChunk(resolve), 0);
  }
  const result = await new Promise(resolve=>tryChunk(resolve));

  if (!running) { updateStatus("Abgebrochen.", "warntext"); return; }
  if (!result){
    updateStatus(`Keine Lösung innerhalb von ${attempts} Versuchen. Max. Versuche erhöhen oder Parameter anpassen.`, "warntext");
    running = false; return;
  }

  const {grid, placed} = result;
  renderGrid(grid);
  document.getElementById("attemptsPill").textContent = `Versuche: ${attempts}`;
  document.getElementById("placedPill").textContent = `Platziert: ${placed.length}`;
  document.getElementById("wordsPlain").textContent = placed.map(p=>p[0]).join("\n");
  const placements = placed.map(p=>`${p[0]} ${p[1]} (${p[2][0]+1},${p[2][1]+1})`).join("\n");
  document.getElementById("placements").textContent = placements;
  const gridSha = sha1hex(grid.join("\n"));
  const wordsSha = sha1hex(placed.map(p=>p[0]).join("\n"));
  document.getElementById("gridSha").textContent = gridSha;
  document.getElementById("wordsSha").textContent = wordsSha;
  const leftover = solver_leftover(grid, placed.map(p=>p[0]));
  document.getElementById("leftover").textContent = leftover;
  updateStatus(leftover === sol ? `Fertig. Lösung nach ${attempts} Versuchen gefunden.` : `Warnung: leftover≠solution (${leftover} ≠ ${sol}).`, leftover===sol ? "ok" : "warntext");
  buildPrintSheet(grid, placed.map(p=>p[0]), sol);
  running = false;
}

function stopSearch(){
  running = false;
  updateStatus("Stoppsignal gesendet. (Warte ggf. auf aktuellen Block.)", "warntext");
}

/*** ---------- Print helpers ---------- ***/
function buildPrintSheet(gridLines, wordsPlaced, solution){
  const wl = document.getElementById("printWordlist");
  const pg = document.getElementById("printGrid");
  wl.textContent = wordsPlaced.join("\n");
  pg.innerHTML = "";
  for (const row of gridLines){
    const r = document.createElement("div");
    r.className = "gridRow";
    for (const ch of row){
      const c = document.createElement("div");
      c.className = "gridCell";
      c.textContent = ch;
      r.appendChild(c);
    }
    pg.appendChild(r);
  }
  document.getElementById("solutionPlaceholder").setAttribute("data-len", solution.length);
}

function ensurePrintSheetFromCurrent(){
  const words = (document.getElementById("wordsPlain").textContent || "").trim().split(/\r?\n/).filter(Boolean);
  const gridDom = document.querySelectorAll("#gridHost .row");
  if (gridDom.length && words.length){
    const gridLines = Array.from(gridDom).map(row => Array.from(row.children).map(c=>c.textContent).join(""));
    const sol = norm(document.getElementById("solution").value);
    buildPrintSheet(gridLines, words, sol);
    return true;
  }
  return false;
}

function openPrint(){
  // Desktop-friendly: try to open native print dialog
  ensurePrintSheetFromCurrent();
  window.print();
}

// In-page preview (mobile-friendly)
function enterPreview(){
  if (!ensurePrintSheetFromCurrent()){
    alert("Erst Puzzle erzeugen (Starten) – dann Vorschau.");
    return;
  }
  document.body.classList.add("preview");
}
function leavePreview(){
  document.body.classList.remove("preview");
}

// Download full app HTML
function downloadHTML(){
  const blob = new Blob([document.documentElement.outerHTML], {type: "text/html"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "woertraetsel_printable.html";
  a.click();
  URL.revokeObjectURL(a.href);
}

// Download print-only HTML
function downloadPrintOnly(){
  if (!ensurePrintSheetFromCurrent()){
    alert("Erst Puzzle erzeugen (Starten) – dann speichern.");
    return;
  }
  const sheet = document.getElementById("sheetRoot").outerHTML;
  const html = `<!doctype html>
<html lang="de"><head><meta charset="utf-8"/>
<title>Worträtsel – Druckseite</title>
<style>
  @page { size: A4 portrait; margin: 14mm; }
  body { background:#fff; color:#000; margin:0; }
  .sheet { width:100%; height:auto; background:#fff; color:#000;
    display:grid; grid-template-columns: 1fr 2fr; grid-template-rows: auto 1fr auto; gap: 10mm; padding: 4mm; box-sizing: border-box; }
  .gridRow { display:grid; grid-auto-flow: column; gap:1.5mm; }
  .gridCell { width:8.5mm; height:8.5mm; border:0.4mm solid #000; display:flex; align-items:center; justify-content:center; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:9pt; background:#fff; color:#000;}
  .wordlist { font-size:11pt; line-height:1.35; white-space:pre-wrap; border:1px solid #000; padding:6mm; border-radius:2mm; background:#fff; }
  .solutionBox { border-top:0.4mm solid #000; padding-top:5mm; font-size:12pt; }
  .title { font-size:16pt; font-weight:700; }
</style></head><body onload="setTimeout(()=>window.print && window.print(), 0)">
${sheet}
</body></html>`;
  const blob = new Blob([html], {type:"text/html"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "woertraetsel_druckseite.html";
  a.click();
  URL.revokeObjectURL(a.href);
}

/*** ---------- File handling & defaults ---------- ***/
document.getElementById("run").addEventListener("click", (e)=>{ e.preventDefault(); startSearch(); });
document.getElementById("stop").addEventListener("click", (e)=>{ e.preventDefault(); stopSearch(); });
document.getElementById("printBtn").addEventListener("click", (e)=>{ e.preventDefault(); openPrint(); });
document.getElementById("previewBtn").addEventListener("click", (e)=>{ e.preventDefault(); enterPreview(); });
document.getElementById("leavePreview").addEventListener("click", (e)=>{ e.preventDefault(); leavePreview(); });
document.getElementById("systemPrint").addEventListener("click", (e)=>{ e.preventDefault(); window.print(); });
document.getElementById("downloadBtn").addEventListener("click", (e)=>{ e.preventDefault(); downloadHTML(); });
document.getElementById("downloadPrintOnlyBtn").addEventListener("click", (e)=>{ e.preventDefault(); downloadPrintOnly(); });

document.getElementById("file").addEventListener("change", async (ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  const txt = await file.text();
  document.getElementById("wordlist").value = txt;
});

document.getElementById("loadDefault").addEventListener("click", ()=>{
  document.getElementById("wordlist").value = DEFAULT_WORDS.trim();
  updateStatus("Standardliste geladen.");
});

/*** ---------- Default list (short placeholder) ---------- ***/
const DEFAULT_WORDS = `
Aal
Abend
Abendessen
Abenteuer
Adler
ängstlich
ärgerlich
ärgern
Affe
Aland
Albatros
allein
Alligator
Alpaka
alt
Ameise
Ameisenbär
Ampel
Amsel
Anakonda
Anfang
Angst
anhalten
ankommen
anmachen
antworten
Anzug
Apfel
April
Arm
Armbanduhr
Arzt
Astronaut
Aufgabe
aufmachen
aufpassen
aufräumen
aufstehen
aufwachen
Augen
Augenblick
Auge
ausatmen
ausmachen
ausruhen
aussuchen
Auto
Baby
Bach
Bagger
Bahnhof
Ball
Ballon
Banane
bauen
Bauer
Bauarbeiter
Bauernhof
Baum
Baumhaus
Bauch
bedeuten
beenden
beginnen
Bein
Beispiel
beißen
bekommen
beleuchten
benutzen
berühren
beschreiben
besonders
bestimmt
besuchen
beten
betteln
Bett
Bibel
Bibliothek
Biene
Bier
Bild
birke
Birne
bitten
blau
Bleistift
Blick
Blitz
Block
Blume
Bluse
Boden
Bohne
Boot
Braten
brauchen
Braten
Bratpfanne
brav
brechen
brennen
Brett
Brief
bringen
Brot
Brücke
Brunnen
Brust
Buch
Buchstabe
Bügel
Bügelbrett
Bügeln
Büro
Bus
Butter
Cousine
Cousin
Computer
Clown
Dach
Dachboden
Dachs
Dalmatiner
dankbar
dauern
decken
dein
denken
Deo
der
Diktat
die
Dienstag
dieser
Diktiergerät
Donner
Donnerstag
doppelt
Dorf
Dose
draußen
drei
drinnen
drohen
du
Duft
Dusche
durstig
Ebbe
echt
Ecke
egal
eilen
ein
einatmen
Einbrecher
einfach
Einfluss
eingeben
einladen
einmal
einpacken
eins
einsteigen
einzeln
Eis
Eisbär
Eisberg
Eisenbahn
eislaufen
Eisvogel
Elch
elektrisch
Elefant
Elternteil
empfehlen
Ende
endlich
eng
Engel
Engpass
enorm
entdecken
Entenküken
entlang
enttäuscht
entwickeln
entzünden
Erbse
Erde
Erdbeere
erdig
erfahren
Erfolg
erfüllen
Ergebnis
erhalten
erinnern
erklären
erledigen
erleben
Ermüdung
ernst
Ernte
erreichbar
Ersatz
Erwartung
erzählen
es
essen
Eule
Fahne
Fahrrad
fahren
Fahrer
fallen
Familie
fangen
Fantasie
Farbe
faul
Faust
Februar
Fehler
Feind
Feld
Fenster
Ferien
fern
Fernbedienung
Fernseher
fertig
fest
Feuer
Feuerwehr
Feuerwerk
Fieber
Film
finden
Finger
fischen
Fisch
Fleisch
Fledermaus
fliegen
Fliege
Flugzeug
Fluss
Flussufer
Flöte
folgen
fordern
formen
Foto
Fotoapparat
Frage
fragen
Franzose
Frau
frei
Freitag
fremd
Freude
Freund
Freundin
freuen
Frieden
frisch
Friseur
Frischkäse
froh
fröhlich
Frucht
Frühling
fühlen
führen
Füller
funktionieren
Furcht
fürchten
Fuß
Fußball
ganz
Gans
Garage
Garten
Gabel
Gebirge
Geburtstag
geduldig
Gefahr
Gefühl
gegen
Gegenteil
gehören
gehen
Geheimnis
Geier
Gelb
Geld
gelb
gelingen
gelb
gemischt
genau
gerade
gern
Geruch
Geschenk
Geschichte
Gesicht
Gespenst
gestern
gesund
getrennt
Getränk
Geweih
Gewitter
Gewürz
gießen
glauben
glatt
Glatze
glauben
Glas
gleich
Glieder
Glocke
glücklich
Gold
Gorilla
Gotteshaus
graben
grad
Gram
Gras
grau
grausam
grell
Grenze
Griff
grill
groß
großartig
großzügig
grün
Grund
Grundschule
Gruppe
Gummi
Gurke
gut
Gürtel
Gymnasium
Haare
hacken
Hafen
Hagel
Hahn
halb
Hälfte
halten
Hammer
Hand
Handgelenk
Handschuh
Handtuch
Handy
Hanf
Hange
Halle
hallo
Halluzination
halten
Hammer
Hamster
Händler
Händchen
Hauptstadt
Haus
Hausaufgabe
Hausfrau
Hausnummer
Haut
Heft
heilen
heiliger
heimlich
heiraten
Heizung
Held
hell
heraus
herstellen
Herd
Herr
Herz
Herbst
heute
Hier
hierher
Himmel
Himbeere
Hindernis
Hobby
hoch
Hocker
holen
Holz
Holztisch
Honig
Horn
Hornisse
Horoskop
Hose
Hotel
Huhn
Hut
Hüfte
Hügel
Husten
Identität
Ideal
Idee
igitt
Igel
Iltis
Imker
immer
in
innen
Insel
Instrument
interessant
irgendwo
Jahr
Januar
Jacke
Jagd
jagen
japanisch
Junge
Jungfrau
Juni
Juli
jung
Kabel
Käfig
Kaffee
Kalender
Kamera
Kamel
Kanal
kalt
Kamera
Kamm
Känguru
kaputt
Kapuze
Karate
Karotte
Karussell
Karte
Kartoffel
Katze
Kaufhaus
käufig
Kaugummi
kaum
Keller
kennen
Keks
Kerze
Kette
keuchen
Kind
Kinderwagen
Kino
Kirsche
Kissen
Kiste
Klamm
Klasse
kleben
Kleid
klein
Klavier
klettern
Klingel
Klo
klopfen
Kneipe
Koch
Kochtopf
Koffer
können
König
Königin
Kopf
Korb
Körper
Krankheit
Krankenhaus
krank
kratzen
Krähe
Krake
Krankenwagen
Krankheit
Kranz
kraus
Kreide
Kreuz
kriechen
Krieg
Kristall
Krone
Krug
Kuchen
Kugel
kuh
Kuhstall
kühn
kühl
Kunst
Künstler
Kürbis
kurz
Lachen
Lachs
Laden
Lager
Lampen
Land
Landkarte
lang
langsam
Lärm
lassen
Lastwagen
laufen
laut
leben
Lebensmittel
Leben
Leder
legen
leicht
Leiter
lernen
lesen
letzt
Leute
Licht
Liebe
lieblich
Liebling
liegen
Linse
Lippe
Löffel
Löwe
Luft
Lüge
lügen
Lust
Luxus
machen
Mädchen
Magen
Magie
Magnet
Malbuch
Maler
Mama
Männer
Mannschaft
Mantel
Markt
Marmelade
Mars
Maschine
Masse
Meer
Meerrettich
Mehrzahl
Melodie
Menü
Mensch
Messer
Metall
Miete
Milch
Minute
Mischung
mit
Mittag
Mittagessen
Mitternacht
Mitte
Mittwoch
Möbel
Möhren
Mohn
Monat
Mond
Montag
Moor
Morgen
Motor
Motorboot
Motorrad
Mühe
Müll
Mund
Musik
Muskel
Mutter
Mütze
Nabel
Nacht
Nachtlicht
Nagel
Nahrung
Namen
Name
Nase
Natur
Neblig
Nebula
nein
Nest
nett
neu
Neugier
nicht
Nichte
Nichts
nieder
Niemandsland
Nilpferd
Norden
Not
Note
Notiz
November
nun
Nummer
Obdach
obwohl
Oberteil
Obst
Ohr
Ohrfeige
Oktober
Olivenöl
Oma
Onkel
Opa
Orange
Orchester
Ordnung
Ort
Osten
Otter
Ozean
Paar
Paket
Papa
Papagei
Papier
Park
Partei
Party
passen
Pause
Peitsche
Pech
Pfeffer
Pferd
Pfirsich
pflanzen
Pflaume
Pflicht
Pfote
Pfütze
Pilz
Pinguin
Pink
Pirouette
Piraten
Pistole
Plakat
Plan
Platz
plötzlich
Polizei
Polizist
Post
Pracht
Praline
Pranke
Prinzip
Professor
Pullover
Punkt
Puppe
Puzzle
Quark
Quatsch
Quelle
Radar
Rakete
Ranzen
Rasen
rasieren
Rat
Rätsel
Ratte
Raum
Raumschiff
räuspern
Regen
Regenbogen
Regenschirm
regelmäßig
Reh
Reifen
Reihenfolge
Reim
Reis
Reise
Reiter
reiten
Rennauto
Rentier
Respekt
Restaurant
retten
richten
Riese
Riesenrad
Riff
Ring
Rippe
Ritter
Robbe
Rock
Rose
rot
Rucksack
Rücken
Ruf
rufen
Ruhe
rund
Sache
Sack
Saft
sagen
Salz
sammeln
Sand
Sandale
Sandburg
Sarg
sauer
sauber
Schaf
schaffen
Schall
schalten
schämen
Schatten
schauen
Scheibe
Scheich
Schein
Scherz
Schiff
schlafen
Schlafsack
Schlange
schlau
schlecht
Schloss
Schluss
Schlüssel
Schmetterling
schminken
Schmutz
Schnabel
Schnee
Schokolade
Schornstein
Schrank
schreien
Schrift
Schuhe
Schule
Schüssel
Schuss
Schwägerin
Schwalbe
schwarz
Schwester
schwimmen
Schwimmbad
Schwein
Schwert
schwer
Schwimmbad
See
Seeigel
Seele
Seestern
Segelboot
sehen
Seil
selbst
selten
September
setzen
Sessel
setzen
Seufzer
sicher
Sieger
Silber
singen
sinken
Sirene
Sitz
Sofa
sofort
Sommer
Sonne
Sonntag
sorgen
Spaß
Spalte
spannen
spannend
sparsam
Spatz
Specht
Speise
sperren
Spiel
Spielplatz
Spielzeug
Spinne
Sport
Sprache
sprechen
springen
Sprung
Stadt
Stadion
Stand
stark
Stange
star
starren
Start
Stativ
Staub
Staubsauger
Staub
Stein
steigen
Stempel
sterben
Steuer
Stimme
Stirn
Stock
Stoff
stolz
Straße
Strand
Strauß
streichen
streiten
Strom
Stuhl
Stunde
Sturm
Sturz
suchen
Süden
Summe
süß
Tafel
Tag
Tagebuch
Tal
Tante
Tasche
Tasse
Taucher
tauschen
Tee
teuer
Text
Theater
Tier
Tiger
Tinte
Tisch
Toblerone
Tochter
Tod
toll
Topf
Tor
tragen
Trainer
treffen
trennen
treu
Treppe
treten
trinken
trocken
Trommel
Trompete
Tropfen
Truhe
Tuch
Tukan
tun
Tunne
Turm
turnen
Ufer
Uhr
umdrehen
Umfang
Umfrage
Umhang
Umgebung
umziehen
Unfall
ungern
Ungeziefer
Universum
Unruhe
Urlaub
Uroma
Uhrzeit
Umschlag
umtauschen
Umwelt
Umzug
vage
Vater
Verein
verhalten
verlassen
verloren
vermeiden
vernünftig
verraten
versprechen
verstehen
verwandeln
verwenden
verzeihen
Video
viel
Vogel
Volk
Volleyball
voll
Vorfahrt
Vorhang
vorstellen
Waffe
Wagen
Wahl
Wahrheit
Wald
wandern
Wange
Wanne
warm
Waschbecken
Waschbär
waschen
Wasser
wechseln
Wecker
Weg
wehtun
wehren
Weihnachten
Weile
Wein
weinen
weiß
weit
Weizen
Welt
Weltall
Wenigkeit
Werkstatt
Wert
Wesen
westlich
Wetter
Wiese
WiFi
wichtig
Wild
Wildschwein
Wind
Winter
Wippe
Wirbel
Wirkung
Wissenschaft
wissen
Wochenende
Woche
wohl
Wohnung
Wolf
Wolke
Wolle
Wort
Wunsch
Wüste
Xylophon
Zahl
zahlen
Zahn
Zahnarzt
Zahnfleisch
Zauber
zaubern
Zauberer
Zebra
zehn
zeigen
Zeiger
Zeile
Zeit
Zeitung
Zelt
zerbrechen
zerreißen
zerstören
Ziege
Zimmer
zirpen
Zitrone
Zoo
Zucker
Zug
zumachen
zurück
zusammen
Zwerg
Zwiebel
`;
document.getElementById("wordlist").value = DEFAULT_WORDS.trim();
</script>
</body>
</html>
